
=== FILE: godot_project_context.txt ===


=== END OF FILE: godot_project_context.txt ===



=== FILE: icon.svg.import ===

[remap]

importer="texture"
type="CompressedTexture2D"
uid="uid://c0fpoieg0g1wb"
path="res://.godot/imported/icon.svg-218a8f2b3041327d8a5756f3a245f83b.ctex"
metadata={
"vram_texture": false
}

[deps]

source_file="res://icon.svg"
dest_files=["res://.godot/imported/icon.svg-218a8f2b3041327d8a5756f3a245f83b.ctex"]

[params]

compress/mode=0
compress/high_quality=false
compress/lossy_quality=0.7
compress/hdr_compression=1
compress/normal_map=0
compress/channel_pack=0
mipmaps/generate=false
mipmaps/limit=-1
roughness/mode=0
roughness/src_normal=""
process/fix_alpha_border=true
process/premult_alpha=false
process/normal_map_invert_y=false
process/hdr_as_srgb=false
process/hdr_clamp_exposure=false
process/size_limit=0
detect_3d/compress_to=1
svg/scale=1.0
editor/scale_with_editor_scale=false
editor/convert_colors_with_editor_theme=false

=== END OF FILE: icon.svg.import ===



=== FILE: project.godot ===

; Engine configuration file.
; It's best edited using the editor UI and not directly,
; since the parameters that go here are not all obvious.
;
; Format:
;   [section] ; section goes between []
;   param=value ; assign values to parameters

config_version=5

[application]

config/name="Qux"
run/main_scene="uid://eorl60j50wro"
config/features=PackedStringArray("4.4", "Forward Plus")
config/icon="res://icon.svg"

[autoload]

LayerManager="*res://core/managers/layer_manager.gd"
SceneManager="*res://core/managers/scene_manager.gd"
EventBus="*res://core/managers/event_bus.gd"
SceneSetManager="*res://core/managers/scene_set_manager.gd"
TransitionManager="*res://core/managers/transition_manager.gd"
PauseManager="*res://core/managers/pause_manager.gd"

[editor_plugins]

enabled=PackedStringArray("res://addons/autoregistry/plugin.cfg")

[input]

pause={
"deadzone": 0.2,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194305,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
]
}

=== END OF FILE: project.godot ===



=== FILE: addons\autoregistry\generator.gd ===

@tool
extends RefCounted


const REGISTRY_CONFIGS = [
	{
		"name": "Core",
		"root_path": "res://data/core/",
		"autogen_path": "res://core/registry/"
	},
	{
		"name": "Game",
		"root_path": "res://data/game/",
		"autogen_path": "res://game/registry/"
	}
]

const REGISTRY_HEADER = """# THIS FILE IS AUTOGENERATED BY THE AUTOREGISTRY PLUGIN.
# DO NOT EDIT MANUALLY. ANY CHANGES WILL BE OVERWRITTEN.
#
# Class containing preloaded data entries for the '%s' registry (%s).

"""


func generate():
	for config in REGISTRY_CONFIGS:
		print("AutoRegistry: Processing registry config: %s" % config.name)
		_cleanup_autogen_dir(config.autogen_path)
		
		DirAccess.make_dir_absolute(config.autogen_path)

		var root_dir := DirAccess.open(config.root_path)
		
		if not root_dir:
			printerr("AutoRegistry: Registry root path not found for %s: %s" % [config.name, config.root_path])
			continue

		for subfolder_name in root_dir.get_directories():
			var registry_class_name = subfolder_name.to_pascal_case()
			_generate_registry_class(registry_class_name, subfolder_name, config)


func _cleanup_autogen_dir(autogen_path: String):
	var dir := DirAccess.open(autogen_path)
	
	if not dir:
		return

	for file_name in dir.get_files():
		dir.remove(autogen_path.path_join(file_name))


func _collect_resources_recursively(path: String, prefix: String = "") -> Array[Dictionary]:
	var collected_files: Array[Dictionary] = []
	var dir = DirAccess.open(path)
	if not dir:
		printerr("AutoRegistry: Could not open directory for recursive scan: %s" % path)
		return collected_files

	for file_name in dir.get_files():
		if file_name.ends_with(".tres") or file_name.ends_with(".res"):
			var base_name = file_name.get_basename()
			var const_name = (prefix + base_name).to_upper()
			var resource_path = path.path_join(file_name)
			collected_files.append({"const_name": const_name, "resource_path": resource_path})

	for sub_dir_name in dir.get_directories():
		var new_prefix = prefix + sub_dir_name + "_"
		var sub_dir_path = path.path_join(sub_dir_name)
		collected_files.append_array(_collect_resources_recursively(sub_dir_path, new_prefix))

	return collected_files


func _generate_registry_class(registry_class_name: String, registry_folder: String, config: Dictionary):
	var file_path = config.autogen_path.path_join(registry_folder.to_snake_case() + ".gd")

	var content = REGISTRY_HEADER % [registry_class_name, config.name]
	content += "class_name %s\n\n" % registry_class_name

	var consts: Array[String] = []
	var full_registry_path: String = config.root_path.path_join(registry_folder)

	var all_resource_info = _collect_resources_recursively(full_registry_path)
	
	if all_resource_info.is_empty():
		var file = FileAccess.open(file_path, FileAccess.WRITE)
		if file:
			file.store_string(content)
		else:
			printerr("AutoRegistry: Failed to write empty registry file: %s" % file_path)
		return

	var return_type = _infer_type_from_tres_file(all_resource_info[0].resource_path)

	for res_info in all_resource_info:
		content += "const %s: %s = preload(\"%s\")\n" % [res_info.const_name, return_type, res_info.resource_path]
		consts.append(res_info.const_name)
	
	if not consts.is_empty():
		content += "\nstatic var ALL: Array[%s] = [%s]\n" % [return_type, (", ".join(consts))]
		content += "\nstatic func get_all() -> Array[%s]:\n" % return_type
		content += "    return ALL\n"
	else:
		content += "\nstatic var ALL: Array[%s] = []\n" % return_type
		content += "\nstatic func get_all() -> Array[%s]:\n" % return_type
		content += "    return ALL\n"

	var file = FileAccess.open(file_path, FileAccess.WRITE)

	if file:
		file.store_string(content)
	else:
		printerr("AutoRegistry: Failed to write registry file: %s" % file_path)


func _infer_type_from_tres_file(file_path: String) -> String:
	var file := FileAccess.open(file_path, FileAccess.READ)
	
	if not file:
		push_warning("AutoRegistry: Could not open file to infer type: " + file_path)
		return "Resource"

	var first_line := file.get_line()
	
	if first_line == null or first_line.is_empty():
		var content_sample = file.get_as_text(true)
		file.seek(0)
		
		var regex_gd_resource = RegEx.new()
		regex_gd_resource.compile("\\[gd_resource.*?type=\"([^\"]+)\"")
		var result_gd_resource = regex_gd_resource.search(content_sample)
		
		if result_gd_resource:
			return result_gd_resource.get_string(1)
		
		push_warning("AutoRegistry: File is empty or first line unreadable for type inference: " + file_path)
		return "Resource"

	var regex := RegEx.new()
	regex.compile('script_class\\s*=\\s*"([^"]+)"') 
	var result := regex.search(first_line)
	
	if result:
		return result.get_string(1)

	push_warning("AutoRegistry: Could not infer type from file: " + file_path)
	return "Resource"

=== END OF FILE: addons\autoregistry\generator.gd ===



=== FILE: addons\autoregistry\plugin.cfg ===

[plugin]

name="AutoRegistry"
description="Automatically generates registry files from directories."
author="SnappyDragon"
version=""
script="plugin.gd"

=== END OF FILE: addons\autoregistry\plugin.cfg ===



=== FILE: addons\autoregistry\plugin.gd ===

@tool
extends EditorPlugin


const Generator = preload("res://addons/autoregistry/generator.gd")

var regenerate_button
var debounce_timer
var filesystem
var generator

const DB_SCAN_PATH = "res://data/registry/"


func _enter_tree():
	regenerate_button = Button.new()
	regenerate_button.flat = true
	regenerate_button.text = "AutoRegistry"
	regenerate_button.tooltip_text = "Forces regeneration of registries."
	regenerate_button.icon = get_editor_interface().get_base_control().get_theme_icon("Reload", "EditorIcons")
	regenerate_button.pressed.connect(_trigger_regeneration)
	add_control_to_container(CONTAINER_TOOLBAR, regenerate_button)
	
	var toolbar = regenerate_button.get_parent()
	toolbar.move_child(regenerate_button, 4)
	regenerate_button.set_visible(false)
	
	debounce_timer = Timer.new()
	debounce_timer.wait_time = 0.5
	debounce_timer.one_shot = true
	debounce_timer.timeout.connect(_on_debounce_timer_timeout)
	add_child(debounce_timer)
	
	filesystem = get_editor_interface().get_resource_filesystem()
	filesystem.filesystem_changed.connect(_on_filesystem_changed)
	
	generator = Generator.new()


func _exit_tree():
	filesystem.filesystem_changed.disconnect(_on_filesystem_changed)
	remove_control_from_container(CONTAINER_TOOLBAR, regenerate_button)
	regenerate_button.queue_free()
	debounce_timer.queue_free()


func _on_filesystem_changed():
	debounce_timer.start()


func _on_debounce_timer_timeout():
	_trigger_regeneration()


func _trigger_regeneration():
	print("AutoRegistry: Regenerating registries...")
	generator.generate()
	print("AutoRegistry: Regeneration complete.")

=== END OF FILE: addons\autoregistry\plugin.gd ===



=== FILE: core\definitions\event_entry.gd ===

class_name EventEntry extends Resource

@export var data_schema: Dictionary[String, Variant.Type]

=== END OF FILE: core\definitions\event_entry.gd ===



=== FILE: core\definitions\layer_entry.gd ===

class_name LayerEntry extends Resource

@export var name: String
@export var layer: int

=== END OF FILE: core\definitions\layer_entry.gd ===



=== FILE: core\definitions\scene_entry.gd ===

class_name SceneEntry extends Resource

@export_file("*.tscn") var path: String
@export var layer_entry: LayerEntry

=== END OF FILE: core\definitions\scene_entry.gd ===



=== FILE: core\definitions\scene_set_entry.gd ===

class_name SceneSetEntry extends Resource

@export var scenes: Array[SceneEntry]
@export var is_pausable: bool = false

=== END OF FILE: core\definitions\scene_set_entry.gd ===



=== FILE: core\definitions\transition_entry.gd ===

class_name TransitionEntry extends Resource

@export var scene_entry: SceneEntry

=== END OF FILE: core\definitions\transition_entry.gd ===



=== FILE: core\managers\event_bus.gd ===

extends Node


func subscribe(event_entry: EventEntry, callable: Callable) -> void:
	var signal_name = event_entry.resource_path
	
	if not has_signal(signal_name):
		add_user_signal(signal_name)
	
	connect(event_entry.resource_path, callable)


func unsubscribe(event_entry: EventEntry, callable: Callable) -> void:
	if is_connected(event_entry.resource_path, callable):
		disconnect(event_entry.resource_path, callable)


func publish(event_entry: EventEntry, data: Dictionary = {}) -> void:
	var signal_name = event_entry.resource_path

	if not _validate_and_register_event(event_entry, data):
		return

	emit_signal(signal_name, data)


func wait_for(event_entry: EventEntry) -> Dictionary:
	var signal_name = event_entry.resource_path

	if not has_signal(signal_name):
		add_user_signal(signal_name)

	var signal_args: Array = await Signal(self, signal_name)
	
	if signal_args.size() == 1 and signal_args[0] is Dictionary:
		return signal_args[0]
	else:
		push_error("EventBus: Unexpected signal arguments for event '%s'. Args: %s" % [signal_name, str(signal_args)])
		return {}


func _validate_and_register_event(event_entry: EventEntry, data: Dictionary) -> bool:
	var signal_name = event_entry.resource_path
	
	if event_entry.data_schema:
		if not _validate_data(event_entry.data_schema, data):
			push_error("EventBus: Invalid payload for event '%s'. Event not published." % signal_name)
			return false
	elif not data.is_empty():
		push_error("EventBus: Event '%s' has no schema but received data. Event not published." % signal_name)
		return false
		
	if not has_signal(signal_name):
		add_user_signal(signal_name)
		
	return true


func _validate_data(schema: Dictionary, data: Dictionary) -> bool:
	if data.size() != schema.size():
		push_warning("EventBus: Validation failed: Data size does not match schema size for schema: %s" % schema.keys())
		return false
	
	for key in schema:
		if not data.has(key):
			push_warning("EventBus: Validation failed: Payload missing required key '%s'." % key)
			return false
		if typeof(data[key]) != schema[key]:
			var expected_type_str = type_string(schema[key])
			var actual_type_str = type_string(typeof(data[key]))
			push_warning("EventBus: Validation failed for key '%s': Expected type %s, got %s." % [key, expected_type_str, actual_type_str])
			return false
	
	return true

=== END OF FILE: core\managers\event_bus.gd ===



=== FILE: core\managers\layer_manager.gd ===

extends Node


var _canvas_layers: Dictionary[StringName, CanvasLayer] = {}


func _ready() -> void:
	var all_layers: Array[LayerEntry] = Layers.get_all()

	for layer_entry in all_layers:
		var canvas_layer := CanvasLayer.new()
		canvas_layer.name = layer_entry.name
		canvas_layer.layer = layer_entry.layer
		_canvas_layers[layer_entry.resource_path] = canvas_layer
		add_child(canvas_layer)


func get_layer(layer_entry: LayerEntry) -> CanvasLayer:
	if not _canvas_layers.has(layer_entry.resource_path):
		push_error("LayerManager does not have a registered layer for: %s" % layer_entry.resource_path)
		return null
	
	return _canvas_layers[layer_entry.resource_path]

=== END OF FILE: core\managers\layer_manager.gd ===



=== FILE: core\managers\pause_manager.gd ===

extends Node


signal paused
signal resumed

var pause_action_name: StringName = &"pause"

var is_paused: bool = false
var _can_pause: bool = false

var _action_exists_in_map: bool = false


func _ready() -> void:
	process_mode = Node.PROCESS_MODE_ALWAYS
	_action_exists_in_map = InputMap.has_action(pause_action_name)

	if not _action_exists_in_map:
		print("PauseManager: Input action '%s' not found in Input Map, falling back to Escape key. Add the action to enable remapping." % pause_action_name)


func _unhandled_input(event: InputEvent) -> void:
	if not _can_pause:
		return

	var pause_requested: bool = false

	if _action_exists_in_map:
		if event.is_action_pressed(pause_action_name):
			pause_requested = true
	
	else:
		if event is InputEventKey and event.keycode == KEY_ESCAPE and event.is_pressed() and not event.is_echo():
			pause_requested = true

	if pause_requested:
		set_pause_state(not is_paused)
		get_viewport().set_input_as_handled()


func set_pause_state(new_state: bool) -> void:
	if new_state == is_paused:
		return

	is_paused = new_state
	get_tree().paused = is_paused

	if is_paused:
		paused.emit()
	else:
		resumed.emit()


func pause() -> void:
	set_pause_state(true)


func resume() -> void:
	set_pause_state(false)


func set_pausable(can_be_paused: bool) -> void:
	_can_pause = can_be_paused

=== END OF FILE: core\managers\pause_manager.gd ===



=== FILE: core\managers\scene_manager.gd ===

extends Node


var _scenes: Dictionary[StringName, Node] = {}


func load_scene(scene_entry: SceneEntry) -> LoadSceneTask:
	var task = LoadSceneTask.new()
	task.scene_entry = scene_entry

	_load_scene(task)

	return task


func unload_scene(scene_entry: SceneEntry) -> void:
	if not scene_entry:
		push_error("SceneManager: Cannot unload scene. The provided SceneEntry is invalid.")
		return
	if not _scenes.has(scene_entry.resource_path):
		return

	var scene_instance = _scenes.get(scene_entry.resource_path)
	if is_instance_valid(scene_instance):
		scene_instance.queue_free()
	_scenes.erase(scene_entry.resource_path)


func get_scene(scene_entry: SceneEntry) -> Node:
	if not scene_entry: return null
	return _scenes.get(scene_entry.resource_path, null)


func is_scene_loaded(scene_entry: SceneEntry) -> bool:
	if not scene_entry: return false
	return _scenes.has(scene_entry.resource_path)


func _load_scene(task: LoadSceneTask) -> void:
	var entry = task.scene_entry
	if not entry or not entry.path:
		push_error("SceneManager: Cannot load scene. Invalid SceneEntry provided to task.")
		return
	if not entry.layer_entry:
		push_error("SceneManager: SceneEntry '%s' is missing a LayerEntry." % entry.resource_path)
		return
		
	if _scenes.has(entry.resource_path):
		task.result = _scenes[entry.resource_path]
		task.completed.emit(task.result)
		return

	var canvas_layer: CanvasLayer = LayerManager.get_layer(entry.layer_entry)
	if not canvas_layer: return
	
	var packed_scene: PackedScene = load(entry.path)
	if not packed_scene:
		push_error("SceneManager: Failed to load scene resource at path: %s" % entry.path)
		return

	var scene_instance = packed_scene.instantiate()
	if not scene_instance:
		push_error("SceneManager: Failed to instantiate scene from path: %s" % entry.path)
		return

	canvas_layer.add_child(scene_instance)
	await scene_instance.tree_entered

	_scenes[entry.resource_path] = scene_instance
	
	task.result = scene_instance
	task.completed.emit(task.result)

=== END OF FILE: core\managers\scene_manager.gd ===



=== FILE: core\managers\scene_set_manager.gd ===

extends Node

signal scene_set_initialized(context: SceneSetContext)

var _current_set: SceneSetEntry
var _is_transitioning: bool = false


func change_set(new_set_entry: SceneSetEntry) -> void:
	if not new_set_entry:
		push_error("SceneSetManager: Cannot change_set to a null SceneSetEntry.")
		return

	if _is_transitioning:
		push_warning("SceneSetManager: Transition already in progress. Ignoring change set request.")
		return
		
	if _current_set and new_set_entry.resource_path == _current_set.resource_path:
		push_warning("SceneSetManager: Scene set '%s' is already loaded." % _current_set.resource_path)
		return
		
	_execute_transition(new_set_entry)


func reload_current_set() -> void:
	if _is_transitioning:
		push_warning("SceneSetManager: Transition already in progress. Ignoring reload request.")
		return
	if not _current_set:
		push_error("SceneSetManager: Cannot reload, no scene set is currently loaded.")
		return
	_execute_transition(_current_set)


func _execute_transition(target_set: SceneSetEntry) -> void:
	_is_transitioning = true
	
	PauseManager.set_pause_state(false)
	
	if _current_set:
		await TransitionManager.play_intro()
		for scene_entry in _current_set.scenes:
			SceneManager.unload_scene(scene_entry)
	
	var context = SceneSetContext.new()
	context.entry = target_set

	var load_tasks: Array[LoadSceneTask] = []
	for scene_entry in target_set.scenes:
		var load_task: LoadSceneTask = SceneManager.load_scene(scene_entry) 
		load_tasks.append(load_task)
		
	for task in load_tasks:
		var loaded_node: Node = await task.completed
		
		if loaded_node and task.scene_entry:
			context.scenes[task.scene_entry] = loaded_node
	
	_current_set = target_set
	PauseManager.set_pausable(_current_set.is_pausable)
	
	scene_set_initialized.emit(context)
	
	await TransitionManager.play_outro()

	_is_transitioning = false

=== END OF FILE: core\managers\scene_set_manager.gd ===



=== FILE: core\managers\transition_manager.gd ===

extends Node


var _current_transition_entry: TransitionEntry
var _current_transition: Transition


func set_current_transition(transition_entry: TransitionEntry) -> bool:
	_current_transition = null
	_current_transition_entry = null

	if not transition_entry:
		return true

	if not transition_entry.scene_entry:
		push_error("TransitionManager: Cannot set transition. The provided TransitionEntry '%s' has no SceneEntry defined." % transition_entry.resource_path)
		return false

	if not SceneManager.is_scene_loaded(transition_entry.scene_entry):
		push_error("TransitionManager: Cannot set transition '%s'. Its scene has not been loaded by SceneManager." % transition_entry.resource_path)
		return false

	var scene_instance = SceneManager.get_scene(transition_entry.scene_entry)
	if not scene_instance is Transition:
		var type_str = "null" if not scene_instance else scene_instance.get_class()
		push_error("TransitionManager: Cannot set transition '%s'. Its scene node is a '%s', not a 'Transition'." % [transition_entry.resource_path, type_str])
		return false

	_current_transition = scene_instance
	_current_transition_entry = transition_entry
	return true


func play_intro() -> void:
	if _current_transition:
		await _current_transition.play_intro()


func play_outro() -> void:
	if _current_transition:
		await _current_transition.play_outro()

=== END OF FILE: core\managers\transition_manager.gd ===



=== FILE: core\nodes\transition.gd ===

@tool
class_name Transition
extends Control


var animation_player: AnimationPlayer

const INTRO_ANIM_NAME := "intro"
const OUTRO_ANIM_NAME := "outro"


func _get_configuration_warnings() -> PackedStringArray:
	var warnings := PackedStringArray()
	var found_anim_player := false
	
	for i in get_child_count():
		var child = get_child(i)
		if child is AnimationPlayer:
			animation_player = child
			found_anim_player = true
			break
	
	if not found_anim_player:
		warnings.append("Transition requires an AnimationPlayer child.")
	else:
		if not animation_player.has_animation(INTRO_ANIM_NAME):
			warnings.append("AnimationPlayer is missing the '%s' animation." % INTRO_ANIM_NAME)
		if not animation_player.has_animation(OUTRO_ANIM_NAME):
			warnings.append("AnimationPlayer is missing the '%s' animation." % OUTRO_ANIM_NAME)
	return warnings


func _ready():
	visible = false
	
	for child in get_children():
		if child is AnimationPlayer:
			animation_player = child
			break

	if not animation_player:
		push_error("Transition on '%s': AnimationPlayer child not found!" % get_path())


func play_intro() -> void:
	if animation_player and animation_player.has_animation(INTRO_ANIM_NAME):
		visible = true
		animation_player.play(INTRO_ANIM_NAME)
		await animation_player.animation_finished
	else:
		push_warning("'%s': '%s' animation not found or AnimationPlayer missing." % [get_path(), INTRO_ANIM_NAME])


func play_outro() -> void:
	if animation_player and animation_player.has_animation(OUTRO_ANIM_NAME):
		animation_player.play(OUTRO_ANIM_NAME)
		await animation_player.animation_finished
		visible = false
	else:
		push_warning("'%s': '%s' animation not found or AnimationPlayer missing." % [get_path(), OUTRO_ANIM_NAME])

=== END OF FILE: core\nodes\transition.gd ===



=== FILE: core\registry\events.gd ===

# THIS FILE IS AUTOGENERATED BY THE AUTOREGISTRY PLUGIN.
# DO NOT EDIT MANUALLY. ANY CHANGES WILL BE OVERWRITTEN.
#
# Class containing preloaded data entries for the 'Events' registry (Core).

class_name Events

const DUMMY_EVENT: EventEntry = preload("res://data/core/events/dummy_event.tres")

static var ALL: Array[EventEntry] = [DUMMY_EVENT]

static func get_all() -> Array[EventEntry]:
    return ALL

=== END OF FILE: core\registry\events.gd ===



=== FILE: core\registry\layers.gd ===

# THIS FILE IS AUTOGENERATED BY THE AUTOREGISTRY PLUGIN.
# DO NOT EDIT MANUALLY. ANY CHANGES WILL BE OVERWRITTEN.
#
# Class containing preloaded data entries for the 'Layers' registry (Core).

class_name Layers

const DEBUG: LayerEntry = preload("res://data/core/layers/debug.tres")
const GAME: LayerEntry = preload("res://data/core/layers/game.tres")
const HUD: LayerEntry = preload("res://data/core/layers/hud.tres")
const MENU: LayerEntry = preload("res://data/core/layers/menu.tres")
const TRANSITION: LayerEntry = preload("res://data/core/layers/transition.tres")

static var ALL: Array[LayerEntry] = [DEBUG, GAME, HUD, MENU, TRANSITION]

static func get_all() -> Array[LayerEntry]:
    return ALL

=== END OF FILE: core\registry\layers.gd ===



=== FILE: core\registry\scenes.gd ===

# THIS FILE IS AUTOGENERATED BY THE AUTOREGISTRY PLUGIN.
# DO NOT EDIT MANUALLY. ANY CHANGES WILL BE OVERWRITTEN.
#
# Class containing preloaded data entries for the 'Scenes' registry (Core).

class_name Scenes

const MAIN: SceneEntry = preload("res://data/core/scenes/main.tres")

static var ALL: Array[SceneEntry] = [MAIN]

static func get_all() -> Array[SceneEntry]:
    return ALL

=== END OF FILE: core\registry\scenes.gd ===



=== FILE: core\registry\scene_sets.gd ===

# THIS FILE IS AUTOGENERATED BY THE AUTOREGISTRY PLUGIN.
# DO NOT EDIT MANUALLY. ANY CHANGES WILL BE OVERWRITTEN.
#
# Class containing preloaded data entries for the 'SceneSets' registry (Core).

class_name SceneSets

const DEFAULT: SceneSetEntry = preload("res://data/core/scene_sets/default.tres")

static var ALL: Array[SceneSetEntry] = [DEFAULT]

static func get_all() -> Array[SceneSetEntry]:
    return ALL

=== END OF FILE: core\registry\scene_sets.gd ===



=== FILE: core\registry\transitions.gd ===

# THIS FILE IS AUTOGENERATED BY THE AUTOREGISTRY PLUGIN.
# DO NOT EDIT MANUALLY. ANY CHANGES WILL BE OVERWRITTEN.
#
# Class containing preloaded data entries for the 'Transitions' registry (Core).

class_name Transitions

const DEFAULT: TransitionEntry = preload("res://data/core/transitions/default.tres")

static var ALL: Array[TransitionEntry] = [DEFAULT]

static func get_all() -> Array[TransitionEntry]:
    return ALL

=== END OF FILE: core\registry\transitions.gd ===



=== FILE: core\runtime\load_scene_task.gd ===

class_name LoadSceneTask extends RefCounted


signal completed(result: Node)


var scene_entry: SceneEntry
var result: Node

=== END OF FILE: core\runtime\load_scene_task.gd ===



=== FILE: core\runtime\scene_set_context.gd ===

class_name SceneSetContext
extends RefCounted

var entry: SceneSetEntry
var scenes: Dictionary[SceneEntry, Node] = {}


func get_scene(scene_entry: SceneEntry) -> Node:
	return scenes.get(scene_entry, null)

=== END OF FILE: core\runtime\scene_set_context.gd ===



=== FILE: data\core\events\dummy_event.tres ===

[gd_resource type="Resource" script_class="EventEntry" load_steps=2 format=3 uid="uid://b6us0wi62cos4"]

[ext_resource type="Script" uid="uid://cl85ijuvs5gfk" path="res://core/definitions/event_entry.gd" id="1_001oq"]

[resource]
script = ExtResource("1_001oq")
data_schema = Dictionary[String, int]({
"flag": 1
})
metadata/_custom_type_script = "uid://cl85ijuvs5gfk"

=== END OF FILE: data\core\events\dummy_event.tres ===



=== FILE: data\core\layers\debug.tres ===

[gd_resource type="Resource" script_class="LayerEntry" load_steps=2 format=3 uid="uid://b0km8u6v8nppn"]

[ext_resource type="Script" uid="uid://bm1rx04nc3pis" path="res://core/definitions/layer_entry.gd" id="1_310nk"]

[resource]
script = ExtResource("1_310nk")
name = "Debug"
layer = 999
metadata/_custom_type_script = "uid://bm1rx04nc3pis"

=== END OF FILE: data\core\layers\debug.tres ===



=== FILE: data\core\layers\game.tres ===

[gd_resource type="Resource" script_class="LayerEntry" load_steps=2 format=3 uid="uid://dv7wikmtcpl7u"]

[ext_resource type="Script" uid="uid://bm1rx04nc3pis" path="res://core/definitions/layer_entry.gd" id="1_b0347"]

[resource]
script = ExtResource("1_b0347")
name = "Game"
layer = 1
metadata/_custom_type_script = "uid://bm1rx04nc3pis"

=== END OF FILE: data\core\layers\game.tres ===



=== FILE: data\core\layers\hud.tres ===

[gd_resource type="Resource" script_class="LayerEntry" load_steps=2 format=3 uid="uid://c3f4d3ksv7kg1"]

[ext_resource type="Script" uid="uid://bm1rx04nc3pis" path="res://core/definitions/layer_entry.gd" id="1_dee76"]

[resource]
script = ExtResource("1_dee76")
name = "HUD"
layer = 10
metadata/_custom_type_script = "uid://bm1rx04nc3pis"

=== END OF FILE: data\core\layers\hud.tres ===



=== FILE: data\core\layers\menu.tres ===

[gd_resource type="Resource" script_class="LayerEntry" load_steps=2 format=3 uid="uid://iyhdit84hd44"]

[ext_resource type="Script" uid="uid://bm1rx04nc3pis" path="res://core/definitions/layer_entry.gd" id="1_t4hfs"]

[resource]
script = ExtResource("1_t4hfs")
name = "Menu"
layer = 50
metadata/_custom_type_script = "uid://bm1rx04nc3pis"

=== END OF FILE: data\core\layers\menu.tres ===



=== FILE: data\core\layers\transition.tres ===

[gd_resource type="Resource" script_class="LayerEntry" load_steps=2 format=3 uid="uid://bt55bdvy2tw3j"]

[ext_resource type="Script" uid="uid://bm1rx04nc3pis" path="res://core/definitions/layer_entry.gd" id="1_cns2l"]

[resource]
script = ExtResource("1_cns2l")
name = "Transition"
layer = 100
metadata/_custom_type_script = "uid://bm1rx04nc3pis"

=== END OF FILE: data\core\layers\transition.tres ===



=== FILE: data\core\scenes\main.tres ===

[gd_resource type="Resource" script_class="SceneEntry" load_steps=3 format=3 uid="uid://cr08q7cljg3j8"]

[ext_resource type="Script" uid="uid://dycnwq5aitmfg" path="res://core/definitions/scene_entry.gd" id="1_6h1f8"]
[ext_resource type="Resource" uid="uid://b0km8u6v8nppn" path="res://data/core/layers/debug.tres" id="1_fr1mb"]

[resource]
script = ExtResource("1_6h1f8")
path = "uid://eorl60j50wro"
layer_entry = ExtResource("1_fr1mb")
metadata/_custom_type_script = "uid://dycnwq5aitmfg"

=== END OF FILE: data\core\scenes\main.tres ===



=== FILE: data\core\scene_sets\default.tres ===

[gd_resource type="Resource" script_class="SceneSetEntry" load_steps=4 format=3 uid="uid://ci8gsqe0lcv48"]

[ext_resource type="Script" uid="uid://dycnwq5aitmfg" path="res://core/definitions/scene_entry.gd" id="1_8yp2l"]
[ext_resource type="Resource" uid="uid://cr08q7cljg3j8" path="res://data/core/scenes/main.tres" id="2_y7ut3"]
[ext_resource type="Script" uid="uid://bw6bt8uu7yj57" path="res://core/definitions/scene_set_entry.gd" id="3_opv6y"]

[resource]
script = ExtResource("3_opv6y")
scenes = Array[ExtResource("1_8yp2l")]([ExtResource("2_y7ut3")])
metadata/_custom_type_script = "uid://bw6bt8uu7yj57"

=== END OF FILE: data\core\scene_sets\default.tres ===



=== FILE: data\core\transitions\default.tres ===

[gd_resource type="Resource" script_class="TransitionEntry" load_steps=2 format=3 uid="uid://clnwmviky1rv5"]

[ext_resource type="Script" uid="uid://bkasf4whiowvu" path="res://core/definitions/transition_entry.gd" id="1_650xr"]

[resource]
script = ExtResource("1_650xr")
metadata/_custom_type_script = "uid://bkasf4whiowvu"

=== END OF FILE: data\core\transitions\default.tres ===



=== FILE: game\main.gd ===

extends Node


func _ready():
	SceneSetManager.change_set(SceneSets.TEST)

=== END OF FILE: game\main.gd ===



=== FILE: game\main.tscn ===

[gd_scene load_steps=2 format=3 uid="uid://eorl60j50wro"]

[ext_resource type="Script" uid="uid://bwkkeg8xggq1q" path="res://game/main.gd" id="1_oa506"]

[node name="Main" type="Node"]
script = ExtResource("1_oa506")

=== END OF FILE: game\main.tscn ===


