
=== FILE: export_presets.cfg ===

[preset.0]

name="Web"
platform="Web"
runnable=true
advanced_options=false
dedicated_server=false
custom_features=""
export_filter="all_resources"
include_filter=""
exclude_filter=""
export_path=""
patches=PackedStringArray()
encryption_include_filters=""
encryption_exclude_filters=""
seed=0
encrypt_pck=false
encrypt_directory=false
script_export_mode=2

[preset.0.options]

custom_template/debug=""
custom_template/release=""
variant/extensions_support=false
variant/thread_support=false
vram_texture_compression/for_desktop=true
vram_texture_compression/for_mobile=false
html/export_icon=true
html/custom_html_shell=""
html/head_include=""
html/canvas_resize_policy=2
html/focus_canvas_on_start=true
html/experimental_virtual_keyboard=false
progressive_web_app/enabled=false
progressive_web_app/ensure_cross_origin_isolation_headers=true
progressive_web_app/offline_page=""
progressive_web_app/display=1
progressive_web_app/orientation=0
progressive_web_app/icon_144x144=""
progressive_web_app/icon_180x180=""
progressive_web_app/icon_512x512=""
progressive_web_app/background_color=Color(0, 0, 0, 1)

=== END OF FILE: export_presets.cfg ===



=== FILE: godot_project_context.txt ===


=== END OF FILE: godot_project_context.txt ===



=== FILE: icon.svg.import ===

[remap]

importer="texture"
type="CompressedTexture2D"
uid="uid://c0fpoieg0g1wb"
path="res://.godot/imported/icon.svg-218a8f2b3041327d8a5756f3a245f83b.ctex"
metadata={
"vram_texture": false
}

[deps]

source_file="res://icon.svg"
dest_files=["res://.godot/imported/icon.svg-218a8f2b3041327d8a5756f3a245f83b.ctex"]

[params]

compress/mode=0
compress/high_quality=false
compress/lossy_quality=0.7
compress/hdr_compression=1
compress/normal_map=0
compress/channel_pack=0
mipmaps/generate=false
mipmaps/limit=-1
roughness/mode=0
roughness/src_normal=""
process/fix_alpha_border=true
process/premult_alpha=false
process/normal_map_invert_y=false
process/hdr_as_srgb=false
process/hdr_clamp_exposure=false
process/size_limit=0
detect_3d/compress_to=1
svg/scale=1.0
editor/scale_with_editor_scale=false
editor/convert_colors_with_editor_theme=false

=== END OF FILE: icon.svg.import ===



=== FILE: project.godot ===

; Engine configuration file.
; It's best edited using the editor UI and not directly,
; since the parameters that go here are not all obvious.
;
; Format:
;   [section] ; section goes between []
;   param=value ; assign values to parameters

config_version=5

[application]

config/name="Clockwork"
run/main_scene="uid://eorl60j50wro"
config/features=PackedStringArray("4.4", "Forward Plus")
config/icon="res://icon.svg"

[autoload]

LayerManager="*res://core/managers/layer_manager.gd"
SceneManager="*res://core/managers/scene_manager.gd"
EventBus="*res://core/managers/event_bus.gd"
SceneSetManager="*res://core/managers/scene_set_manager.gd"
TransitionManager="*res://core/managers/transition_manager.gd"
PauseManager="*res://core/managers/pause_manager.gd"

[display]

window/size/viewport_width=1280
window/size/viewport_height=720

[editor_plugins]

enabled=PackedStringArray("res://addons/autoregistry/plugin.cfg")

[input]

pause={
"deadzone": 0.2,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194305,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
]
}
move_up={
"deadzone": 0.2,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194320,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":87,"key_label":0,"unicode":119,"location":0,"echo":false,"script":null)
, Object(InputEventJoypadMotion,"resource_local_to_scene":false,"resource_name":"","device":-1,"axis":1,"axis_value":-1.0,"script":null)
, Object(InputEventJoypadButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"button_index":11,"pressure":0.0,"pressed":true,"script":null)
]
}
move_left={
"deadzone": 0.2,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194319,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":65,"key_label":0,"unicode":97,"location":0,"echo":false,"script":null)
, Object(InputEventJoypadMotion,"resource_local_to_scene":false,"resource_name":"","device":-1,"axis":0,"axis_value":-1.0,"script":null)
, Object(InputEventJoypadButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"button_index":13,"pressure":0.0,"pressed":true,"script":null)
]
}
move_down={
"deadzone": 0.2,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194322,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":83,"key_label":0,"unicode":115,"location":0,"echo":false,"script":null)
, Object(InputEventJoypadMotion,"resource_local_to_scene":false,"resource_name":"","device":-1,"axis":1,"axis_value":1.0,"script":null)
, Object(InputEventJoypadButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"button_index":12,"pressure":0.0,"pressed":true,"script":null)
]
}
move_right={
"deadzone": 0.2,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194321,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":68,"key_label":0,"unicode":100,"location":0,"echo":false,"script":null)
, Object(InputEventJoypadMotion,"resource_local_to_scene":false,"resource_name":"","device":-1,"axis":0,"axis_value":1.0,"script":null)
, Object(InputEventJoypadButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"button_index":14,"pressure":0.0,"pressed":true,"script":null)
]
}

[rendering]

anti_aliasing/quality/msaa_2d=2
anti_aliasing/quality/msaa_3d=2

=== END OF FILE: project.godot ===



=== FILE: addons\autoregistry\generator.gd ===

@tool
extends RefCounted


const REGISTRY_CONFIGS = [
	{
		"name": "Core",
		"root_path": "res://data/core/",
		"autogen_path": "res://core/registry/"
	},
	{
		"name": "Game",
		"root_path": "res://data/game/",
		"autogen_path": "res://game/registry/"
	}
]

const REGISTRY_HEADER = """# THIS FILE IS AUTOGENERATED BY THE AUTOREGISTRY PLUGIN.
# DO NOT EDIT MANUALLY. ANY CHANGES WILL BE OVERWRITTEN.
#
# Class containing preloaded data entries for the '%s' registry (%s).

"""


func generate():
	for config in REGISTRY_CONFIGS:
		print("AutoRegistry: Processing registry config: %s" % config.name)
		_cleanup_autogen_dir(config.autogen_path)
		
		DirAccess.make_dir_absolute(config.autogen_path)

		var root_dir := DirAccess.open(config.root_path)
		
		if not root_dir:
			printerr("AutoRegistry: Registry root path not found for %s: %s" % [config.name, config.root_path])
			continue

		for subfolder_name in root_dir.get_directories():
			var registry_class_name = subfolder_name.to_pascal_case()
			_generate_registry_class(registry_class_name, subfolder_name, config)


func _cleanup_autogen_dir(autogen_path: String):
	var dir := DirAccess.open(autogen_path)
	
	if not dir:
		return

	for file_name in dir.get_files():
		dir.remove(autogen_path.path_join(file_name))


func _collect_resources_recursively(path: String, prefix: String = "") -> Array[Dictionary]:
	var collected_files: Array[Dictionary] = []
	var dir = DirAccess.open(path)
	if not dir:
		printerr("AutoRegistry: Could not open directory for recursive scan: %s" % path)
		return collected_files

	for file_name in dir.get_files():
		if file_name.ends_with(".tres") or file_name.ends_with(".res"):
			var base_name = file_name.get_basename()
			var const_name = (prefix + base_name).to_upper()
			var resource_path = path.path_join(file_name)
			collected_files.append({"const_name": const_name, "resource_path": resource_path})

	for sub_dir_name in dir.get_directories():
		var new_prefix = prefix + sub_dir_name + "_"
		var sub_dir_path = path.path_join(sub_dir_name)
		collected_files.append_array(_collect_resources_recursively(sub_dir_path, new_prefix))

	return collected_files


func _generate_registry_class(registry_class_name: String, registry_folder: String, config: Dictionary):
	var file_path = config.autogen_path.path_join(registry_folder.to_snake_case() + ".gd")

	var content = REGISTRY_HEADER % [registry_class_name, config.name]
	content += "class_name %s\n\n" % registry_class_name

	var consts: Array[String] = []
	var full_registry_path: String = config.root_path.path_join(registry_folder)

	var all_resource_info = _collect_resources_recursively(full_registry_path)
	
	if all_resource_info.is_empty():
		var file = FileAccess.open(file_path, FileAccess.WRITE)
		if file:
			file.store_string(content)
		else:
			printerr("AutoRegistry: Failed to write empty registry file: %s" % file_path)
		return

	var return_type = _infer_type_from_tres_file(all_resource_info[0].resource_path)

	for res_info in all_resource_info:
		content += "const %s: %s = preload(\"%s\")\n" % [res_info.const_name, return_type, res_info.resource_path]
		consts.append(res_info.const_name)
	
	if not consts.is_empty():
		content += "\nstatic var ALL: Array[%s] = [%s]\n" % [return_type, (", ".join(consts))]
		content += "\nstatic func get_all() -> Array[%s]:\n" % return_type
		content += "    return ALL\n"
	else:
		content += "\nstatic var ALL: Array[%s] = []\n" % return_type
		content += "\nstatic func get_all() -> Array[%s]:\n" % return_type
		content += "    return ALL\n"

	var file = FileAccess.open(file_path, FileAccess.WRITE)

	if file:
		file.store_string(content)
	else:
		printerr("AutoRegistry: Failed to write registry file: %s" % file_path)


func _infer_type_from_tres_file(file_path: String) -> String:
	var file := FileAccess.open(file_path, FileAccess.READ)
	
	if not file:
		push_warning("AutoRegistry: Could not open file to infer type: " + file_path)
		return "Resource"

	var first_line := file.get_line()
	
	if first_line == null or first_line.is_empty():
		var content_sample = file.get_as_text(true)
		file.seek(0)
		
		var regex_gd_resource = RegEx.new()
		regex_gd_resource.compile("\\[gd_resource.*?type=\"([^\"]+)\"")
		var result_gd_resource = regex_gd_resource.search(content_sample)
		
		if result_gd_resource:
			return result_gd_resource.get_string(1)
		
		push_warning("AutoRegistry: File is empty or first line unreadable for type inference: " + file_path)
		return "Resource"

	var regex := RegEx.new()
	regex.compile('script_class\\s*=\\s*"([^"]+)"') 
	var result := regex.search(first_line)
	
	if result:
		return result.get_string(1)

	push_warning("AutoRegistry: Could not infer type from file: " + file_path)
	return "Resource"

=== END OF FILE: addons\autoregistry\generator.gd ===



=== FILE: addons\autoregistry\plugin.cfg ===

[plugin]

name="AutoRegistry"
description="Automatically generates registry files from directories."
author="SnappyDragon"
version=""
script="plugin.gd"

=== END OF FILE: addons\autoregistry\plugin.cfg ===



=== FILE: addons\autoregistry\plugin.gd ===

@tool
extends EditorPlugin


const Generator = preload("res://addons/autoregistry/generator.gd")

var regenerate_button
var debounce_timer
var filesystem
var generator

const DB_SCAN_PATH = "res://data/registry/"


func _enter_tree():
	regenerate_button = Button.new()
	regenerate_button.flat = true
	regenerate_button.text = "AutoRegistry"
	regenerate_button.tooltip_text = "Forces regeneration of registries."
	regenerate_button.icon = get_editor_interface().get_base_control().get_theme_icon("Reload", "EditorIcons")
	regenerate_button.pressed.connect(_trigger_regeneration)
	add_control_to_container(CONTAINER_TOOLBAR, regenerate_button)
	
	var toolbar = regenerate_button.get_parent()
	toolbar.move_child(regenerate_button, 4)
	regenerate_button.set_visible(false)
	
	debounce_timer = Timer.new()
	debounce_timer.wait_time = 0.5
	debounce_timer.one_shot = true
	debounce_timer.timeout.connect(_on_debounce_timer_timeout)
	add_child(debounce_timer)
	
	filesystem = get_editor_interface().get_resource_filesystem()
	filesystem.filesystem_changed.connect(_on_filesystem_changed)
	
	generator = Generator.new()


func _exit_tree():
	filesystem.filesystem_changed.disconnect(_on_filesystem_changed)
	remove_control_from_container(CONTAINER_TOOLBAR, regenerate_button)
	regenerate_button.queue_free()
	debounce_timer.queue_free()


func _on_filesystem_changed():
	debounce_timer.start()


func _on_debounce_timer_timeout():
	_trigger_regeneration()


func _trigger_regeneration():
	print("AutoRegistry: Regenerating registries...")
	generator.generate()
	print("AutoRegistry: Regeneration complete.")

=== END OF FILE: addons\autoregistry\plugin.gd ===



=== FILE: assets\shaders\toon.gdshader ===

shader_type spatial;
render_mode diffuse_toon, specular_schlick_ggx, cull_back;

uniform float rim: hint_range(0.0, 1.0, 0.01) = 0.5;
uniform float rim_threshold: hint_range(0.0, 1.0, 0.01) = 0.5;

uniform float emission: hint_range(0.0, 1.0, 0.1) = 0.0;
uniform float specular: hint_range(0.0, 1.0, 0.05) = 0.5;
uniform vec3 specular_color: source_color = vec3(0.5);
uniform float roughness: hint_range(0.0, 1.0, 0.1) = 1.0;

uniform bool is_normal_symmetric = false;
uniform float normal_scale: hint_range(0.0, 5.0, 0.1) = 1.0;
uniform sampler2D normal_map: hint_normal,repeat_enable;
uniform sampler2D roughness_map: hint_roughness_g,repeat_enable;
uniform vec4 albedo_color: source_color = vec4(1.0);
uniform vec4 albedo_color2: source_color = vec4(0.0, 0.0, 0.0, 1.0);
uniform sampler2D diffuse_map: source_color,repeat_enable;

uniform sampler2D specular_map: hint_roughness_r,repeat_enable;
uniform sampler2D ramp: source_color, repeat_disable;

varying float s1;
varying vec3 vex;

vec3 get_gradient_color(float position) {
    return texture(ramp, vec2(position, 0.5)).rgb;
}

float fresnel(float amount, vec3 normal, vec3 view)
{
	return pow((1.0 - clamp(dot(normalize(normal), normalize(view)), 0.0, 1.0)), amount);
}

vec3 screen(vec3 base, vec3 blend){
	return 1.0 - (1.0 - base) * (1.0 - blend);
}
vec3 soft_light(vec3 base, vec3 blend){
	vec3 limit = step(0.5, blend);
	return mix(2.0 * base * blend + base * base * (1.0 - 2.0 * blend), sqrt(base) * (2.0 * blend - 1.0) + (2.0 * base) * (1.0 - blend), limit);
}

void vertex() {
	vex = VERTEX;
}

void fragment() {
	vec2 uv = UV;
	NORMAL_MAP = vec3(texture(normal_map, uv).xyz);
	NORMAL_MAP_DEPTH = normal_scale;
	if(is_normal_symmetric){
		vec3 normal_invert_y = NORMAL_MAP;
		normal_invert_y.y = 1.0 - normal_invert_y.y;
		if (vex.x < 0.0) {
			NORMAL_MAP = normal_invert_y;
		}
	}
	ALBEDO = vec3(texture(diffuse_map, uv).rgb) * albedo_color.rgb + albedo_color2.rgb;
	ROUGHNESS = texture(roughness_map, UV).g * roughness * 0.9;
	EMISSION = ALBEDO * emission;
	SPECULAR = texture(specular_map, UV).r * specular;
	s1 = SPECULAR;
}

void light(){
	float NdotL = dot(NORMAL, LIGHT);
	//rim
	float basic_fresnel = fresnel(3.0, NORMAL, VIEW);
	float gradient_rim = step(rim_threshold, basic_fresnel) * basic_fresnel * pow(rim, 0.5);
	//diffuse
	float NdotL_clamp = clamp(NdotL, -1.0f, 1.0f);
	float gradient = mix(0.01f,0.99f, (NdotL_clamp + 1.0)*0.5 * ATTENUATION);
	vec3 color_ramp = get_gradient_color(max(gradient, gradient_rim));
	vec3 diffus_light = ALBEDO * color_ramp;
	vec3 mix_diffus_light = soft_light(diffus_light, LIGHT_COLOR);
	DIFFUSE_LIGHT = mix(mix_diffus_light, diffus_light, 0.5);
	//specular
	float rr = mix(0.99f, 0.01f, ROUGHNESS);
	vec3 H = normalize(VIEW + LIGHT);
	float NdotH = clamp(dot(NORMAL, H), 0.0, 1.0) * ATTENUATION;
	float gradient2 = clamp(pow(NdotH, 16.0/(1.0-rr)), 0.1, 0.99);
	vec3 color_ramp2 = get_gradient_color(clamp(NdotH * (1.0-ROUGHNESS), 0.01, 0.99));
	color_ramp2 = mix(vec3(0.0), color_ramp2, gradient2);
	vec3 specular_color_rgb = min(color_ramp2, specular_color.rgb) * s1;
	vec3 specular_light = screen(specular_color_rgb, LIGHT_COLOR * rr * color_ramp2);
	SPECULAR_LIGHT += mix(vec3(0.0), specular_light, s1);
}
=== END OF FILE: assets\shaders\toon.gdshader ===



=== FILE: core\definitions\event_entry.gd ===

class_name EventEntry extends Resource

@export var data_schema: Dictionary[String, Variant.Type]

=== END OF FILE: core\definitions\event_entry.gd ===



=== FILE: core\definitions\layer_entry.gd ===

class_name LayerEntry extends Resource

@export var name: String
@export var layer: int

=== END OF FILE: core\definitions\layer_entry.gd ===



=== FILE: core\definitions\scene_entry.gd ===

class_name SceneEntry extends Resource

@export_file("*.tscn") var path: String
@export var layer_entry: LayerEntry

=== END OF FILE: core\definitions\scene_entry.gd ===



=== FILE: core\definitions\scene_set_entry.gd ===

class_name SceneSetEntry extends Resource

@export var scenes: Array[SceneEntry]
@export var is_pausable: bool = false

=== END OF FILE: core\definitions\scene_set_entry.gd ===



=== FILE: core\definitions\transition_entry.gd ===

class_name TransitionEntry extends Resource

@export var scene_entry: SceneEntry

=== END OF FILE: core\definitions\transition_entry.gd ===



=== FILE: core\managers\event_bus.gd ===

extends Node


func subscribe(event_entry: EventEntry, callable: Callable) -> void:
	var signal_name = event_entry.resource_path
	
	if not has_signal(signal_name):
		add_user_signal(signal_name)
	
	connect(event_entry.resource_path, callable)


func unsubscribe(event_entry: EventEntry, callable: Callable) -> void:
	if is_connected(event_entry.resource_path, callable):
		disconnect(event_entry.resource_path, callable)


func publish(event_entry: EventEntry, data: Dictionary = {}) -> void:
	var signal_name = event_entry.resource_path

	if not _validate_and_register_event(event_entry, data):
		return

	emit_signal(signal_name, data)


func wait_for(event_entry: EventEntry) -> Dictionary:
	var signal_name = event_entry.resource_path

	if not has_signal(signal_name):
		add_user_signal(signal_name)

	var signal_args: Array = await Signal(self, signal_name)
	
	if signal_args.size() == 1 and signal_args[0] is Dictionary:
		return signal_args[0]
	else:
		push_error("EventBus: Unexpected signal arguments for event '%s'. Args: %s" % [signal_name, str(signal_args)])
		return {}


func _validate_and_register_event(event_entry: EventEntry, data: Dictionary) -> bool:
	var signal_name = event_entry.resource_path
	
	if event_entry.data_schema:
		if not _validate_data(event_entry.data_schema, data):
			push_error("EventBus: Invalid payload for event '%s'. Event not published." % signal_name)
			return false
	elif not data.is_empty():
		push_error("EventBus: Event '%s' has no schema but received data. Event not published." % signal_name)
		return false
		
	if not has_signal(signal_name):
		add_user_signal(signal_name)
		
	return true


func _validate_data(schema: Dictionary, data: Dictionary) -> bool:
	if data.size() != schema.size():
		push_warning("EventBus: Validation failed: Data size does not match schema size for schema: %s" % schema.keys())
		return false
	
	for key in schema:
		if not data.has(key):
			push_warning("EventBus: Validation failed: Payload missing required key '%s'." % key)
			return false
		if typeof(data[key]) != schema[key]:
			var expected_type_str = type_string(schema[key])
			var actual_type_str = type_string(typeof(data[key]))
			push_warning("EventBus: Validation failed for key '%s': Expected type %s, got %s." % [key, expected_type_str, actual_type_str])
			return false
	
	return true

=== END OF FILE: core\managers\event_bus.gd ===



=== FILE: core\managers\layer_manager.gd ===

extends Node


var _canvas_layers: Dictionary[StringName, CanvasLayer] = {}


func _ready() -> void:
	var all_layers: Array[LayerEntry] = Layers.get_all()

	for layer_entry in all_layers:
		var canvas_layer := CanvasLayer.new()
		canvas_layer.name = layer_entry.name
		canvas_layer.layer = layer_entry.layer
		_canvas_layers[layer_entry.resource_path] = canvas_layer
		add_child(canvas_layer)


func get_layer(layer_entry: LayerEntry) -> CanvasLayer:
	if not _canvas_layers.has(layer_entry.resource_path):
		push_error("LayerManager does not have a registered layer for: %s" % layer_entry.resource_path)
		return null
	
	return _canvas_layers[layer_entry.resource_path]

=== END OF FILE: core\managers\layer_manager.gd ===



=== FILE: core\managers\pause_manager.gd ===

extends Node


signal paused
signal resumed

var pause_action_name: StringName = &"pause"

var is_paused: bool = false
var _can_pause: bool = false

var _action_exists_in_map: bool = false


func _ready() -> void:
	process_mode = Node.PROCESS_MODE_ALWAYS
	_action_exists_in_map = InputMap.has_action(pause_action_name)

	if not _action_exists_in_map:
		print("PauseManager: Input action '%s' not found in Input Map, falling back to Escape key. Add the action to enable remapping." % pause_action_name)


func _unhandled_input(event: InputEvent) -> void:
	if not _can_pause:
		return

	var pause_requested: bool = false

	if _action_exists_in_map:
		if event.is_action_pressed(pause_action_name):
			pause_requested = true
	
	else:
		if event is InputEventKey and event.keycode == KEY_ESCAPE and event.is_pressed() and not event.is_echo():
			pause_requested = true

	if pause_requested:
		set_pause_state(not is_paused)
		get_viewport().set_input_as_handled()


func set_pause_state(new_state: bool) -> void:
	if new_state == is_paused:
		return

	is_paused = new_state
	get_tree().paused = is_paused

	if is_paused:
		paused.emit()
	else:
		resumed.emit()


func pause() -> void:
	set_pause_state(true)


func resume() -> void:
	set_pause_state(false)


func set_pausable(can_be_paused: bool) -> void:
	_can_pause = can_be_paused

=== END OF FILE: core\managers\pause_manager.gd ===



=== FILE: core\managers\scene_manager.gd ===

extends Node


var _scenes: Dictionary[StringName, Node] = {}


func load_scene(scene_entry: SceneEntry) -> LoadSceneTask:
	var task = LoadSceneTask.new()
	task.scene_entry = scene_entry

	_load_scene(task)

	return task


func unload_scene(scene_entry: SceneEntry) -> void:
	if not scene_entry:
		push_error("SceneManager: Cannot unload scene. The provided SceneEntry is invalid.")
		return
	if not _scenes.has(scene_entry.resource_path):
		return

	var scene_instance = _scenes.get(scene_entry.resource_path)
	if is_instance_valid(scene_instance):
		scene_instance.queue_free()
	_scenes.erase(scene_entry.resource_path)


func get_scene(scene_entry: SceneEntry) -> Node:
	if not scene_entry: return null
	return _scenes.get(scene_entry.resource_path, null)


func is_scene_loaded(scene_entry: SceneEntry) -> bool:
	if not scene_entry: return false
	return _scenes.has(scene_entry.resource_path)


func _load_scene(task: LoadSceneTask) -> void:
	var entry = task.scene_entry
	if not entry or not entry.path:
		push_error("SceneManager: Cannot load scene. Invalid SceneEntry provided to task.")
		return
	if not entry.layer_entry:
		push_error("SceneManager: SceneEntry '%s' is missing a LayerEntry." % entry.resource_path)
		return
		
	if _scenes.has(entry.resource_path):
		task.result = _scenes[entry.resource_path]
		task.completed.emit(task.result)
		return

	var canvas_layer: CanvasLayer = LayerManager.get_layer(entry.layer_entry)
	if not canvas_layer: return
	
	var packed_scene: PackedScene = load(entry.path)
	if not packed_scene:
		push_error("SceneManager: Failed to load scene resource at path: %s" % entry.path)
		return

	var scene_instance = packed_scene.instantiate()
	if not scene_instance:
		push_error("SceneManager: Failed to instantiate scene from path: %s" % entry.path)
		return

	canvas_layer.add_child(scene_instance)
	await scene_instance.tree_entered

	_scenes[entry.resource_path] = scene_instance
	
	task.result = scene_instance
	task.completed.emit(task.result)

=== END OF FILE: core\managers\scene_manager.gd ===



=== FILE: core\managers\scene_set_manager.gd ===

extends Node

signal scene_set_initialized(context: SceneSetContext)

var _current_set: SceneSetEntry
var _is_transitioning: bool = false


func change_set(new_set_entry: SceneSetEntry) -> void:
	if not new_set_entry:
		push_error("SceneSetManager: Cannot change_set to a null SceneSetEntry.")
		return

	if _is_transitioning:
		push_warning("SceneSetManager: Transition already in progress. Ignoring change set request.")
		return
		
	if _current_set and new_set_entry.resource_path == _current_set.resource_path:
		push_warning("SceneSetManager: Scene set '%s' is already loaded." % _current_set.resource_path)
		return
		
	_execute_transition(new_set_entry)


func reload_current_set() -> void:
	if _is_transitioning:
		push_warning("SceneSetManager: Transition already in progress. Ignoring reload request.")
		return
	if not _current_set:
		push_error("SceneSetManager: Cannot reload, no scene set is currently loaded.")
		return
	_execute_transition(_current_set)


func _execute_transition(target_set: SceneSetEntry) -> void:
	_is_transitioning = true
	
	PauseManager.set_pause_state(false)
	
	if _current_set:
		await TransitionManager.play_intro()
		for scene_entry in _current_set.scenes:
			SceneManager.unload_scene(scene_entry)
	
	var context = SceneSetContext.new()
	context.entry = target_set

	var load_tasks: Array[LoadSceneTask] = []
	for scene_entry in target_set.scenes:
		var load_task: LoadSceneTask = SceneManager.load_scene(scene_entry) 
		load_tasks.append(load_task)
		
	for task in load_tasks:
		var loaded_node: Node = await task.completed
		
		if loaded_node and task.scene_entry:
			context.scenes[task.scene_entry] = loaded_node
	
	_current_set = target_set
	PauseManager.set_pausable(_current_set.is_pausable)
	
	scene_set_initialized.emit(context)
	
	await TransitionManager.play_outro()

	_is_transitioning = false

=== END OF FILE: core\managers\scene_set_manager.gd ===



=== FILE: core\managers\transition_manager.gd ===

extends Node


var _current_transition_entry: TransitionEntry
var _current_transition: Transition


func set_current_transition(transition_entry: TransitionEntry) -> bool:
	_current_transition = null
	_current_transition_entry = null

	if not transition_entry:
		return true

	if not transition_entry.scene_entry:
		push_error("TransitionManager: Cannot set transition. The provided TransitionEntry '%s' has no SceneEntry defined." % transition_entry.resource_path)
		return false

	if not SceneManager.is_scene_loaded(transition_entry.scene_entry):
		push_error("TransitionManager: Cannot set transition '%s'. Its scene has not been loaded by SceneManager." % transition_entry.resource_path)
		return false

	var scene_instance = SceneManager.get_scene(transition_entry.scene_entry)
	if not scene_instance is Transition:
		var type_str = "null" if not scene_instance else scene_instance.get_class()
		push_error("TransitionManager: Cannot set transition '%s'. Its scene node is a '%s', not a 'Transition'." % [transition_entry.resource_path, type_str])
		return false

	_current_transition = scene_instance
	_current_transition_entry = transition_entry
	return true


func play_intro() -> void:
	if _current_transition:
		await _current_transition.play_intro()


func play_outro() -> void:
	if _current_transition:
		await _current_transition.play_outro()

=== END OF FILE: core\managers\transition_manager.gd ===



=== FILE: core\nodes\transition.gd ===

@tool
class_name Transition
extends Control


var animation_player: AnimationPlayer

const INTRO_ANIM_NAME := "intro"
const OUTRO_ANIM_NAME := "outro"


func _get_configuration_warnings() -> PackedStringArray:
	var warnings := PackedStringArray()
	var found_anim_player := false
	
	for i in get_child_count():
		var child = get_child(i)
		if child is AnimationPlayer:
			animation_player = child
			found_anim_player = true
			break
	
	if not found_anim_player:
		warnings.append("Transition requires an AnimationPlayer child.")
	else:
		if not animation_player.has_animation(INTRO_ANIM_NAME):
			warnings.append("AnimationPlayer is missing the '%s' animation." % INTRO_ANIM_NAME)
		if not animation_player.has_animation(OUTRO_ANIM_NAME):
			warnings.append("AnimationPlayer is missing the '%s' animation." % OUTRO_ANIM_NAME)
	return warnings


func _ready():
	visible = false
	
	for child in get_children():
		if child is AnimationPlayer:
			animation_player = child
			break

	if not animation_player:
		push_error("Transition on '%s': AnimationPlayer child not found!" % get_path())


func play_intro() -> void:
	if animation_player and animation_player.has_animation(INTRO_ANIM_NAME):
		visible = true
		animation_player.play(INTRO_ANIM_NAME)
		await animation_player.animation_finished
	else:
		push_warning("'%s': '%s' animation not found or AnimationPlayer missing." % [get_path(), INTRO_ANIM_NAME])


func play_outro() -> void:
	if animation_player and animation_player.has_animation(OUTRO_ANIM_NAME):
		animation_player.play(OUTRO_ANIM_NAME)
		await animation_player.animation_finished
		visible = false
	else:
		push_warning("'%s': '%s' animation not found or AnimationPlayer missing." % [get_path(), OUTRO_ANIM_NAME])

=== END OF FILE: core\nodes\transition.gd ===



=== FILE: core\registry\events.gd ===

# THIS FILE IS AUTOGENERATED BY THE AUTOREGISTRY PLUGIN.
# DO NOT EDIT MANUALLY. ANY CHANGES WILL BE OVERWRITTEN.
#
# Class containing preloaded data entries for the 'Events' registry (Core).

class_name Events

const PLAYER_MOVED: EventEntry = preload("res://data/core/events/player/moved.tres")

static var ALL: Array[EventEntry] = [PLAYER_MOVED]

static func get_all() -> Array[EventEntry]:
    return ALL

=== END OF FILE: core\registry\events.gd ===



=== FILE: core\registry\layers.gd ===

# THIS FILE IS AUTOGENERATED BY THE AUTOREGISTRY PLUGIN.
# DO NOT EDIT MANUALLY. ANY CHANGES WILL BE OVERWRITTEN.
#
# Class containing preloaded data entries for the 'Layers' registry (Core).

class_name Layers

const DEBUG: LayerEntry = preload("res://data/core/layers/debug.tres")
const GAME: LayerEntry = preload("res://data/core/layers/game.tres")
const HUD: LayerEntry = preload("res://data/core/layers/hud.tres")
const MENU: LayerEntry = preload("res://data/core/layers/menu.tres")
const TRANSITION: LayerEntry = preload("res://data/core/layers/transition.tres")

static var ALL: Array[LayerEntry] = [DEBUG, GAME, HUD, MENU, TRANSITION]

static func get_all() -> Array[LayerEntry]:
    return ALL

=== END OF FILE: core\registry\layers.gd ===



=== FILE: core\registry\scenes.gd ===

# THIS FILE IS AUTOGENERATED BY THE AUTOREGISTRY PLUGIN.
# DO NOT EDIT MANUALLY. ANY CHANGES WILL BE OVERWRITTEN.
#
# Class containing preloaded data entries for the 'Scenes' registry (Core).

class_name Scenes

const TEST: SceneEntry = preload("res://data/core/scenes/test.tres")

static var ALL: Array[SceneEntry] = [TEST]

static func get_all() -> Array[SceneEntry]:
    return ALL

=== END OF FILE: core\registry\scenes.gd ===



=== FILE: core\registry\scene_sets.gd ===

# THIS FILE IS AUTOGENERATED BY THE AUTOREGISTRY PLUGIN.
# DO NOT EDIT MANUALLY. ANY CHANGES WILL BE OVERWRITTEN.
#
# Class containing preloaded data entries for the 'SceneSets' registry (Core).

class_name SceneSets

const TEST: SceneSetEntry = preload("res://data/core/scene_sets/test.tres")

static var ALL: Array[SceneSetEntry] = [TEST]

static func get_all() -> Array[SceneSetEntry]:
    return ALL

=== END OF FILE: core\registry\scene_sets.gd ===



=== FILE: core\registry\transitions.gd ===

# THIS FILE IS AUTOGENERATED BY THE AUTOREGISTRY PLUGIN.
# DO NOT EDIT MANUALLY. ANY CHANGES WILL BE OVERWRITTEN.
#
# Class containing preloaded data entries for the 'Transitions' registry (Core).

class_name Transitions

const DEFAULT: TransitionEntry = preload("res://data/core/transitions/default.tres")

static var ALL: Array[TransitionEntry] = [DEFAULT]

static func get_all() -> Array[TransitionEntry]:
    return ALL

=== END OF FILE: core\registry\transitions.gd ===



=== FILE: core\runtime\load_scene_task.gd ===

class_name LoadSceneTask extends RefCounted


@warning_ignore("unused_signal")
signal completed(result: Node)


var scene_entry: SceneEntry
var result: Node

=== END OF FILE: core\runtime\load_scene_task.gd ===



=== FILE: core\runtime\scene_set_context.gd ===

class_name SceneSetContext
extends RefCounted

var entry: SceneSetEntry
var scenes: Dictionary[SceneEntry, Node] = {}


func get_scene(scene_entry: SceneEntry) -> Node:
	return scenes.get(scene_entry, null)

=== END OF FILE: core\runtime\scene_set_context.gd ===



=== FILE: data\core\events\player\moved.tres ===

[gd_resource type="Resource" script_class="EventEntry" load_steps=2 format=3 uid="uid://b6us0wi62cos4"]

[ext_resource type="Script" uid="uid://cl85ijuvs5gfk" path="res://core/definitions/event_entry.gd" id="1_x07w8"]

[resource]
script = ExtResource("1_x07w8")
data_schema = Dictionary[String, int]({
"player_position": 9
})
metadata/_custom_type_script = "uid://cl85ijuvs5gfk"

=== END OF FILE: data\core\events\player\moved.tres ===



=== FILE: data\core\layers\debug.tres ===

[gd_resource type="Resource" script_class="LayerEntry" load_steps=2 format=3 uid="uid://b0km8u6v8nppn"]

[ext_resource type="Script" uid="uid://bm1rx04nc3pis" path="res://core/definitions/layer_entry.gd" id="1_310nk"]

[resource]
script = ExtResource("1_310nk")
name = "Debug"
layer = 999
metadata/_custom_type_script = "uid://bm1rx04nc3pis"

=== END OF FILE: data\core\layers\debug.tres ===



=== FILE: data\core\layers\game.tres ===

[gd_resource type="Resource" script_class="LayerEntry" load_steps=2 format=3 uid="uid://dv7wikmtcpl7u"]

[ext_resource type="Script" uid="uid://bm1rx04nc3pis" path="res://core/definitions/layer_entry.gd" id="1_b0347"]

[resource]
script = ExtResource("1_b0347")
name = "Game"
layer = 1
metadata/_custom_type_script = "uid://bm1rx04nc3pis"

=== END OF FILE: data\core\layers\game.tres ===



=== FILE: data\core\layers\hud.tres ===

[gd_resource type="Resource" script_class="LayerEntry" load_steps=2 format=3 uid="uid://c3f4d3ksv7kg1"]

[ext_resource type="Script" uid="uid://bm1rx04nc3pis" path="res://core/definitions/layer_entry.gd" id="1_dee76"]

[resource]
script = ExtResource("1_dee76")
name = "HUD"
layer = 10
metadata/_custom_type_script = "uid://bm1rx04nc3pis"

=== END OF FILE: data\core\layers\hud.tres ===



=== FILE: data\core\layers\menu.tres ===

[gd_resource type="Resource" script_class="LayerEntry" load_steps=2 format=3 uid="uid://iyhdit84hd44"]

[ext_resource type="Script" uid="uid://bm1rx04nc3pis" path="res://core/definitions/layer_entry.gd" id="1_t4hfs"]

[resource]
script = ExtResource("1_t4hfs")
name = "Menu"
layer = 50
metadata/_custom_type_script = "uid://bm1rx04nc3pis"

=== END OF FILE: data\core\layers\menu.tres ===



=== FILE: data\core\layers\transition.tres ===

[gd_resource type="Resource" script_class="LayerEntry" load_steps=2 format=3 uid="uid://bt55bdvy2tw3j"]

[ext_resource type="Script" uid="uid://bm1rx04nc3pis" path="res://core/definitions/layer_entry.gd" id="1_cns2l"]

[resource]
script = ExtResource("1_cns2l")
name = "Transition"
layer = 100
metadata/_custom_type_script = "uid://bm1rx04nc3pis"

=== END OF FILE: data\core\layers\transition.tres ===



=== FILE: data\core\scenes\test.tres ===

[gd_resource type="Resource" script_class="SceneEntry" load_steps=3 format=3 uid="uid://cr08q7cljg3j8"]

[ext_resource type="Resource" uid="uid://dv7wikmtcpl7u" path="res://data/core/layers/game.tres" id="1_gkbsl"]
[ext_resource type="Script" uid="uid://dycnwq5aitmfg" path="res://core/definitions/scene_entry.gd" id="2_8fnjt"]

[resource]
script = ExtResource("2_8fnjt")
path = "uid://d34ivofjap1eb"
layer_entry = ExtResource("1_gkbsl")
metadata/_custom_type_script = "uid://dycnwq5aitmfg"

=== END OF FILE: data\core\scenes\test.tres ===



=== FILE: data\core\scene_sets\test.tres ===

[gd_resource type="Resource" script_class="SceneSetEntry" load_steps=4 format=3 uid="uid://ci8gsqe0lcv48"]

[ext_resource type="Script" uid="uid://dycnwq5aitmfg" path="res://core/definitions/scene_entry.gd" id="1_uij0o"]
[ext_resource type="Resource" uid="uid://cr08q7cljg3j8" path="res://data/core/scenes/test.tres" id="2_0si71"]
[ext_resource type="Script" uid="uid://bw6bt8uu7yj57" path="res://core/definitions/scene_set_entry.gd" id="3_ij7eu"]

[resource]
script = ExtResource("3_ij7eu")
scenes = Array[ExtResource("1_uij0o")]([ExtResource("2_0si71")])
is_pausable = false
metadata/_custom_type_script = "uid://bw6bt8uu7yj57"

=== END OF FILE: data\core\scene_sets\test.tres ===



=== FILE: data\core\transitions\default.tres ===

[gd_resource type="Resource" script_class="TransitionEntry" load_steps=2 format=3 uid="uid://clnwmviky1rv5"]

[ext_resource type="Script" uid="uid://bkasf4whiowvu" path="res://core/definitions/transition_entry.gd" id="1_650xr"]

[resource]
script = ExtResource("1_650xr")
metadata/_custom_type_script = "uid://bkasf4whiowvu"

=== END OF FILE: data\core\transitions\default.tres ===



=== FILE: game\main.gd ===

extends Node


func _ready():
	SceneSetManager.change_set(SceneSets.TEST)

=== END OF FILE: game\main.gd ===



=== FILE: game\main.tscn ===

[gd_scene load_steps=2 format=3 uid="uid://eorl60j50wro"]

[ext_resource type="Script" uid="uid://bwkkeg8xggq1q" path="res://game/main.gd" id="1_oa506"]

[node name="Main" type="Node"]
script = ExtResource("1_oa506")

=== END OF FILE: game\main.tscn ===



=== FILE: game\gameplay\test.tscn ===

[gd_scene load_steps=7 format=3 uid="uid://d34ivofjap1eb"]

[ext_resource type="PackedScene" uid="uid://bsnho2brgxjr6" path="res://game/gameplay/player/player.tscn" id="1_r21rc"]

[sub_resource type="ProceduralSkyMaterial" id="ProceduralSkyMaterial_8pp8y"]
sky_horizon_color = Color(0.662243, 0.671743, 0.686743, 1)
ground_horizon_color = Color(0.662243, 0.671743, 0.686743, 1)

[sub_resource type="Sky" id="Sky_r21rc"]
sky_material = SubResource("ProceduralSkyMaterial_8pp8y")

[sub_resource type="Environment" id="Environment_c2a3t"]
background_mode = 2
sky = SubResource("Sky_r21rc")
tonemap_mode = 2
glow_enabled = true

[sub_resource type="PlaneMesh" id="PlaneMesh_tnan0"]
size = Vector2(20, 20)

[sub_resource type="WorldBoundaryShape3D" id="WorldBoundaryShape3D_2k7eg"]

[node name="Test" type="Node3D"]

[node name="WorldEnvironment" type="WorldEnvironment" parent="."]
environment = SubResource("Environment_c2a3t")

[node name="DirectionalLight3D" type="DirectionalLight3D" parent="."]
transform = Transform3D(-0.866023, -0.433016, 0.250001, 0, 0.499998, 0.866027, -0.500003, 0.749999, -0.43301, 0, 0, 0)
shadow_enabled = true

[node name="MeshInstance3D" type="MeshInstance3D" parent="."]
mesh = SubResource("PlaneMesh_tnan0")

[node name="StaticBody3D" type="StaticBody3D" parent="MeshInstance3D"]

[node name="CollisionShape3D" type="CollisionShape3D" parent="MeshInstance3D/StaticBody3D"]
shape = SubResource("WorldBoundaryShape3D_2k7eg")

[node name="Camera3D" type="Camera3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 0.5, 0.866025, 0, -0.866025, 0.5, 0, 16, 8.5995)
projection = 1
size = 16.0

[node name="Player" parent="." instance=ExtResource("1_r21rc")]

=== END OF FILE: game\gameplay\test.tscn ===



=== FILE: game\gameplay\player\player.gd ===

class_name Player extends CharacterBody3D


@export var speed: float = 4.0

=== END OF FILE: game\gameplay\player\player.gd ===



=== FILE: game\gameplay\player\player.tscn ===

[gd_scene load_steps=5 format=3 uid="uid://bsnho2brgxjr6"]

[ext_resource type="Script" uid="uid://c701senvpk2ds" path="res://game/gameplay/player/player.gd" id="1_ah3ur"]
[ext_resource type="Script" uid="uid://c4a2jeegcd0wm" path="res://game/gameplay/player/player_input_controller.gd" id="2_jfacm"]

[sub_resource type="CapsuleMesh" id="CapsuleMesh_eak53"]

[sub_resource type="CapsuleShape3D" id="CapsuleShape3D_ah3ur"]

[node name="Player" type="CharacterBody3D"]
script = ExtResource("1_ah3ur")

[node name="PlayerInputController" type="Node" parent="."]
script = ExtResource("2_jfacm")

[node name="MeshInstance3D" type="MeshInstance3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0)
mesh = SubResource("CapsuleMesh_eak53")

[node name="CollisionShape3D" type="CollisionShape3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0)
shape = SubResource("CapsuleShape3D_ah3ur")

=== END OF FILE: game\gameplay\player\player.tscn ===



=== FILE: game\gameplay\player\player_input_controller.gd ===

class_name PlayerInputController extends Node


@onready var player: Player = get_owner() as Player


func _physics_process(delta: float):
	var input_vector: Vector2 = Input.get_vector("move_left", "move_right", "move_up", "move_down")
	var direction: Vector3 = Vector3(input_vector.x, 0, input_vector.y).normalized()

	player.velocity.x = direction.x * player.speed
	player.velocity.z = direction.z * player.speed
		
	if not player.is_on_floor():
		player.velocity.y -= 9.8 * delta

	player.move_and_slide()
	EventBus.publish(Events.PLAYER_MOVED, { "player_position": player.global_position })

=== END OF FILE: game\gameplay\player\player_input_controller.gd ===


